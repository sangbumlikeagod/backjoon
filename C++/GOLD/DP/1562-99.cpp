#include <stdio.h>
#include <unordered_map>
#define    MOD    1000000000
// 이 define 굉장히 훌륭함 나도 써먹어야지

int main()
{
    int n; long long ans=0;
    scanf("%d",&n);
    // 이렇게 주소로 받는 이유 무엇 ?
    if(n<10) { puts("0"); return 0; }
		// 10 이전 까지의 전처리
    std::unordered_map<int,long long> dp[2];
		// 해시맵 생성 
    for(int i=1;i<10;i++) dp[1][i*111]=1;
		// 1번째 해시맵에 대해서 111 부터 999까지의 값은 전부 1
        // 아마도 최소값 최대값 마지막 값 인듯
    for(int i=2;i<=n;i++)
    {
        
        int x=i&1;
        // x는 i가 홀수일때는 1이고 짝수일 때는 0
        // i가 홀수일 때는 홀수 해시맵을 지우고 짝수일 때는 짝수 해시맵을 지워서 거기에 새 값들을 채우겠다. 천잰데? 
        // clear연산이 unordered map말고 다른곳에서도 가능한지 보긴 해야함

        dp[x].clear();
        // 아마 해시맵을 지워버린다는 뜻 이전 해시맵, 이후 해시맵 이런식으로 사용하겠다는 것 같음
        
        for(const auto &k : dp[x^1])
        // xor연산으로 다른 해시맵 유연하게 변환, k는 int, longlong의 쌍인것 같음
        // k가 상수라고 지정하는 이유는 뭔가?
        // auto는 왜 쓰일까?
        {
            int a=k.first/100, b=(k.first/10)%10, c=k.first%10;
            // a는 최소값, b는 최대값 c는 마지막값 이것들을 위해 연산한것이고
            long long t = k.second%MOD;
            // 그 키들의 값
            if(c > 0) dp[x][(a-(a==c))*100+b*10+c-1]+=t;
            // 분해된 것을 기반으로 지금 마지막 값이 0 이상일경우 최소값 == 마지막값일 때는 마지막값 - 1 아닐때는 마지막값을 최소값으로 최대값을 b로 마지막값을 c - 1로 하는 해시 생성 
            if(c < 9) dp[x][a*100+(b+(b==c))*10+c+1]+=t;
            // c가 9보다 작을때에만 위로 한칸 가는 해시도 만들어버림 이것역시 최대값과 마지막값이 일치하는가만 고려해서 더해주면 됨
            // 얘도 바텀업 방식으로 미래의 값에 저장을 해준다.
        }
    }
    for(auto &k:dp[n&1]) ans+=(k.first/10==9)?k.second:0;
    // 마지막에 다 끝났을 때 최소값이 0 최대값이 9라면 더해주고 아니면 0을 더한다는 너무나 아름다운 마무리까지 미쳤다 미쳤어 너무 아름답고
    // 이새끼들 언제부터 삼항연산자 지원함? 
    printf("%lld\n", ans%MOD);
}ㅌ